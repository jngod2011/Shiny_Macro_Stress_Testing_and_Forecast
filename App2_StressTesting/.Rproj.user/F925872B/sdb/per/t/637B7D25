{
    "contents" : "#load libraries\nlibrary(Quandl)\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(reshape)\nrequire(rCharts)\nlibrary(reshape2)\nlibrary(shinyBS)\nlibrary(forecast)\nlibrary(mc2d)\nlibrary(stringr)\nlibrary(matrixStats)\nlibrary(DT)\nlibrary(googleVis)\nlibrary(sqldf)\nlibrary(gEcon)\nlibrary(DataCombine)\nlibrary(knitr)\nload(\"shocks.RData\")\nsw_gecon_orig <- make_model('SW_03.gcn')\n#register at quandl\nQuandl.api_key(\"y7xCCmMxsc8_nddWS-yz\")\n#return desc function\ndescfun<-function(series,transform, frequency){\n  eval(parse(text=paste0(\"data<-Quandl(code='\",series,\"',type='raw',\",ifelse(transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",transform,\"',\")),ifelse(frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n  desctab<-as.data.frame(unlist(metaData(data)))\n  colnames(desctab)<-paste0('Data Description for ',series)\n  return(desctab)\n}\nforesimulate<-function(serieslist,data,forecount,simcount)\n{\n  rown<-nrow(data)\n  coln<-ncol(data)\n  for (i in 2:coln)\n  {\n    data <- FillDown(data, colnames(data)[i])\n  }\n  write.csv(data,'test.csv')\n  for (count in 1:length(serieslist)){\n    curr<-data[,count]\n    curr<-ts(curr)\n    fit <- auto.arima(curr, max.p=5, max.q=5,\n                      max.P=2, max.Q=2, max.order=5, max.d=2, max.D=2, \n                      start.p=0, start.q=0, start.P=0, start.Q=0, \n                      stationary=FALSE, seasonal=TRUE,\n                      ic=c(\"aicc\", \"aic\", \"bic\"), stepwise=TRUE, trace=FALSE,\n                      approximation=(length(lh)>100 | frequency(lh)>12), xreg=NULL,\n                      test=c(\"kpss\",\"adf\",\"pp\"), seasonal.test=c(\"ocsb\",\"ch\"),\n                      allowdrift=TRUE, allowmean=TRUE, lambda=NULL, parallel=FALSE, num.cores=2)\n    forecasts<-forecast(fit, h= as.numeric(forecount))\n    write.csv(forecasts,paste0(str_replace(serieslist[count],\"/\",\".\"),\"_\",Sys.Date(),\"_\",forecount,\".csv\"))\n    ndvar<-as.numeric(simcount)\n    shockmat<-matrix(0,as.numeric(simcount),as.numeric(forecount))\n    for (i in 1:as.numeric(forecount))\n    {\n      shockmat[,i]<-mcstoc(rnorm,type=\"V\",mean=mean(fit$residuals,na.rm=TRUE),sd=sd(fit$residuals,na.rm=TRUE))[1:as.numeric(simcount),1,1]\n      shockmat[,i]<-shockmat[,i]+forecasts$mean[i]\n    }\n    shockmat<-as.data.frame(shockmat)\n    write.csv(shockmat,paste0(str_replace(serieslist[count],\"/\",\".\"),\"_\",Sys.Date(),\"_\",forecount,\"_\",simcount,\".csv\"))   \n  }\n}\nsimfun<-function(serieslist,series,transform, frequency,view,forecount,simcount)\n{\n  serieslist<-unlist(strsplit(serieslist,\",\"))\n  if (length(serieslist)==1)\n  {\n    #get data\n    eval(parse(text=paste0(\"data<-Quandl(code=\",str,\",type='raw',\",ifelse(transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",transform,\"',\")),ifelse(frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n  }else{\n    for (count in 1:length(serieslist)){\n      if (count==1){\n        str<-paste0(\"'\",serieslist[count],\"',\")\n      }else if (count<length(serieslist)){\n        str<-paste0(str,\"'\",serieslist[count],\"',\")\n      }else{\n        str<-paste0(str,\"'\",serieslist[count],\"'\")\n      }\n    }\n    str<-paste0(\"c(\",str,\")\")\n    #get data\n    eval(parse(text=paste0(\"data<-Quandl(code=\",str,\",type='ts',\",ifelse(transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",transform,\"',\")),ifelse(frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n  }\n  if(view==\"Forecast\"){\n    if(!file.exists(paste0(paste0(str_replace(series,\"/\",\".\"),\"_\",Sys.Date(),\"_\",forecount,\".csv\")))){\n      foresimulate(serieslist,data,forecount,simcount)\n    }\n    finaldata<-read.csv(paste0(paste0(str_replace(series,\"/\",\".\"),\"_\",Sys.Date(),\"_\",forecount,\".csv\")))\n    colnames(finaldata)<-c(\"Period\",\"Prediction\",\"Lo.80\",\"Hi.80\",\"Lo.95\",\"Hi.95\")\n  }else\n  {\n    if(!file.exists(paste0(paste0(str_replace(series,\"/\",\".\"),\"_\",Sys.Date(),\"_\",forecount,\"_\",simcount,\".csv\")))){\n      foresimulate(serieslist,data,forecount,simcount)\n    }\n    finaldata<-read.csv(paste0(paste0(str_replace(series,\"/\",\".\"),\"_\",Sys.Date(),\"_\",forecount,\"_\",simcount,\".csv\")))\n    for (i in 1:forecount)\n    {\n      if (i==1)\n        str<-\"Period_1\"\n      else\n        str<-c(str,paste0(\"Period_\",i))\n    }\n    colnames(finaldata)<-c(\"Sim#\",str)\n  }\n  return(finaldata)  \n\n  \n}\nshinyServer(function(input, output, session) {\n  observe({\n    #rearrange forecast simulation chooser\n    updateSliderInput(session, \"control\", value = 1,min = 1, max = as.numeric(input$simcount), step =1)\n  })\n  output$chart1 <- renderChart2({\n    serieslist<-unlist(strsplit(input$dataseries,\",\"))\n    # Create chart\n    if (length(serieslist)==1)\n    {\n      #get data\n      eval(parse(text=paste0(\"data<-Quandl(code='\",serieslist,\"',type='raw',\",ifelse(input$transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transform,\"',\")),ifelse(input$frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n      #format Date\n      plotdata = transform(data,Date2 = as.numeric(as.POSIXct(DATE))*1000)\n      plotdata$DATE= NULL\n      plotdata$DATE=plotdata$Date2\n      plotdata$Date2=NULL\n      h1 <- hPlot(VALUE ~ DATE, data = plotdata,type = \"line\", radius=6)\n      h1$xAxis(type = 'datetime', labels = list(format = '{value:%Y-%m-%d}'),title = list(text = paste0(attributes(data)$freq,\"_date from \",attributes(data)$meta$oldest_available_date,\" to \",attributes(data)$meta$newest_available_date)))\n      h1$yAxis(title = list(text = paste0(attributes(data)$meta$dataset_code,\"_ from \",attributes(data)$meta$database_code )))\n    }else{\n      for (count in 1:length(serieslist)){\n        if (count==1){\n          str<-paste0(\"'\",serieslist[count],\"',\")\n        }else if (count<length(serieslist)){\n          str<-paste0(str,\"'\",serieslist[count],\"',\")\n        }else{\n          str<-paste0(str,\"'\",serieslist[count],\"'\")\n        }\n      }\n      str<-paste0(\"c(\",str,\")\")\n      #get data\n      eval(parse(text=paste0(\"data<-Quandl(code=\",str,\",type='raw',\",ifelse(input$transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transform,\"',\")),ifelse(input$frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n      #format Date\n      plotdata = transform(data,Date2 = as.numeric(as.POSIXct(DATE))*1000)\n      plotdata$DATE= NULL\n      plotdata$DATE=plotdata$Date2\n      plotdata$Date2=NULL\n      data<-reshape2::melt(plotdata, id.vars = \"DATE\")\n      h1<-hPlot(x = \"DATE\", y = \"value\", group = \"variable\", data = data)\n      h1$xAxis(type = 'datetime', labels = list(format = '{value:%Y-%m-%d}'),title = list(text = 'Time'))\n      h1$yAxis(title = list(text = paste0('Value')))\n    }\n    return(h1)\n  })\n  output$Descselect = renderUI({\n    selectInput('Descselect2', 'Choose Variable to show Description', serieslist<-unlist(strsplit(input$dataseries,\",\")))\n  })\n  descdata <- reactive(descfun(input$Descselect2,input$transform,input$frequency))\n  output$desctab <- renderTable({ \n    desctab<-descdata()\n  })\n  output$downloadData1 <- downloadHandler(\n    filename = function() { paste('QuandlSeries',Sys.time(), ifelse(input$Format=='csv','.csv','.xls'), sep='') },\n    content = function(file) {\n      serieslist<-unlist(strsplit(input$dataseries,\",\"))\n      # Create chart\n      if (length(serieslist)==1)\n      {\n        #get data\n        eval(parse(text=paste0(\"data<-Quandl(code='\",serieslist,\"',type='raw',\",ifelse(input$transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transform,\"',\")),ifelse(input$frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n      }else{\n        for (count in 1:length(serieslist)){\n          if (count==1){\n            str<-paste0(\"'\",serieslist[count],\"',\")\n          }else if (count<length(serieslist)){\n            str<-paste0(str,\"'\",serieslist[count],\"',\")\n          }else{\n            str<-paste0(str,\"'\",serieslist[count],\"'\")\n          }\n        }\n        str<-paste0(\"c(\",str,\")\")\n        #get data\n        eval(parse(text=paste0(\"data<-Quandl(code=\",str,\",type='raw',\",ifelse(input$transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transform,\"',\")),ifelse(input$frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n        #format Date\n        data<-reshape2::melt(data, id.vars = \"DATE\")\n      }\n      write.csv(data, file)\n    }\n  )\n  output$Varselect = renderUI({\n    selectInput('Varselect2', 'Choose Variable to show Plot and Data', serieslist<-unlist(strsplit(input$dataseriessim,\",\")))\n  })\n  datasim <- reactive(simfun(input$dataseriessim,input$Varselect2,input$transform,input$frequency,input$view,as.numeric(input$forecount),as.numeric(input$simcount)))\n  \n  output$simtab<-DT::renderDataTable({\n    simtab<-datasim()\n  })\n  output$chart2 <- renderChart2({\n    series<-input$Varselect2\n    data<-read.csv(paste0(str_replace(series,\"/\",\".\"),\"_\",Sys.Date(),\"_\",input$forecount,\".csv\"))\n    datasim<-read.csv(paste0(str_replace(series,\"/\",\".\"),\"_\",Sys.Date(),\"_\",input$forecount,\"_\",input$simcount,\".csv\"))\n    alldatasim<-input$dataseriessim\n    serieslist<-unlist(strsplit(input$dataseries,\",\"))\n    iddata<-match(series,serieslist)\n    sign=unlist(strsplit(input$signind,\",\"))\n    sign=sign[iddata]\n    if (sign==\"+\"){\n      if (input$simoutlook==\"Very Positive\")\n      {\n        prc=0.99\n      }else if (input$simoutlook==\"Positive\"){\n        prc=0.75\n      }else if (input$simoutlook==\"Neutral\"){\n        prc=0.5\n      }else if (input$simoutlook==\"Negative\"){\n        prc=0.25\n      }else if (input$simoutlook==\"Very Negative\"){\n        prc=0.01\n      }\n    }else{\n      if (sign==\"-\"){\n        if (input$simoutlook==\"Very Positive\")\n        {\n          prc=0.01\n        }else if (input$simoutlook==\"Positive\"){\n          prc=0.25\n        }else if (input$simoutlook==\"Neutral\"){\n          prc=0.5\n        }else if (input$simoutlook==\"Negative\"){\n          prc=0.75\n        }else if (input$simoutlook==\"Very Negative\"){\n          prc=0.99\n        }\n      }\n    }\n    outlook<-colQuantiles(data.matrix(datasim),probs=seq(from=prc, to=prc, by=0))[2:ncol(datasim)]\n    data<-cbind(data,outlook)\n    data<-reshape2::melt(data, id.vars = \"X\")\n    h1<-hPlot(x = \"X\", y = \"value\", group = \"variable\", data = data)\n    h1$yAxis(title = list(text = paste0(\"Values\")))\n    h1$title(text = paste0(\"Outlook and Average Forecast for _\",series))\n    return(h1)\n  })\n  output$Varsimselect = renderUI({\n    selectInput('Varsimselect2', 'Choose Simulation File', serieslist<-unlist(strsplit(input$dataseriessim,\",\")))\n  })\n  output$downloadData2 <- downloadHandler(\n    filename = function() { paste('QuandlSeries_Sim',Sys.time(), ifelse(input$Format=='csv','.csv','.xls'), sep='') },\n    content = function(file) {\n      data<-read.csv(paste0(str_replace(input$Varsimselect2,\"/\",\".\"),\"_\",Sys.Date(),\"_\",input$forecount,\"_\",input$simcount,\".csv\"))\n      write.csv(data, file)\n    }\n  )\n  output$perselect = renderUI({\n    textInput(\"perselect2\", \"Enter Period:\", \"5\")\n  })\n  output$varsimselect = renderUI({\n    selectInput('varsimselect2', 'Choose Variable to show Histogram', serieslist<-unlist(strsplit(input$dataseriessim,\",\")))\n  })\n  \n  output$Dist <- renderGvis({\n    data<-read.csv(paste0(str_replace(input$varsimselect2,\"/\",\".\"),\"_\",Sys.Date(),\"_\",input$forecount,\"_\",input$simcount,\".csv\"))\n    data<-data[,as.numeric(input$perselect2)+1]\n    data<-as.data.frame(data)\n    colnames(data)<-paste0(\"Simulation_Period_\",input$perselect2)\n    gvis.options <- list(hAxis=\"{title:'Values'}\",\n                         width=900, height=600)\n    hist.gvis <- gvisHistogram(data=data, option=gvis.options)\n    return(hist.gvis)\n  })\n  output$chart3 <- renderChart2({\n    #get dv\n    if (input$depvarchc==\"Input\")\n    {\n      #get data\n      eval(parse(text=paste0(\"dvdata<-Quandl(code='\",input$depvar,\"',type='raw',\",ifelse(input$transform==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transform,\"',\")),ifelse(input$frequency==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequency,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n      colnames(dvdata)<-c('DATE',str_replace(input$depvar,\",\",\".\"))\n    }else{\n      inFile <- input$file1\n      if (is.null(inFile))\n        return(NULL)\n      dvdata<-read.csv(inFile$datapath, header = input$header,sep = input$sep, quote = input$quote)\n    }\n    #get iv\n    serieslist<-unlist(strsplit(input$foreseriessim,\",\"))\n    if (input$Fcore1==TRUE){\n      serieslist<-c(serieslist,'FRED/GDP')\n    }\n    if (input$Fcore2==TRUE){\n      serieslist<-c(serieslist,'FRED/PCECC96')\n    }\n    if (input$Fcore3==TRUE){\n      serieslist<-c(serieslist,'FRED/RINV')\n    }\n    if (input$Fcore4==TRUE){\n      serieslist<-c(serieslist,'FRED/LNU01000000')\n    }\n    if (input$Fcore5==TRUE){\n      serieslist<-c(serieslist,'RATEINF/INFLATION_USA')\n    }\n    if (input$Fcore6==TRUE){\n      serieslist<-c(serieslist,'PERTH/FEDF_M')\n    }\n    # Create chart\n    if (length(serieslist)==1)\n    {\n      #get data\n      eval(parse(text=paste0(\"data<-Quandl(code='\",serieslist,\"',type='raw',\",ifelse(input$transformfore==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transformfore,\"',\")),ifelse(input$frequencyfore==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequencyfore,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n    }else{\n      for (count in 1:length(serieslist)){\n        if (count==1){\n          str<-paste0(\"'\",serieslist[count],\"',\")\n        }else if (count<length(serieslist)){\n          str<-paste0(str,\"'\",serieslist[count],\"',\")\n        }else{\n          str<-paste0(str,\"'\",serieslist[count],\"'\")\n        }\n      }\n      str<-paste0(\"c(\",str,\")\")\n      #get data\n      eval(parse(text=paste0(\"data<-Quandl(code=\",str,\",type='raw',\",ifelse(input$transformfore==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transformfore,\"',\")),ifelse(input$frequencyfore==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequencyfore,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n    }\n    options(sqldf.driver = \"SQLite\") # as per FAQ #7 force SQLite\n    options(gsubfn.engine = \"R\") # as per FAQ #5 use R code rather than tcltk\n    finaldf<-sqldf('select data.*,dvdata.* from data inner join dvdata on data.DATE=dvdata.DATE')\n    finaldf<-subset(finaldf,select=c('DATE',colnames(data)[2:ncol(data)],colnames(dvdata)))\n    finaldf$DATE.1<-NULL\n    rown<-nrow(finaldf)\n    coln<-ncol(finaldf)\n    for (i in 1:coln)\n    {\n      finaldf <- FillDown(finaldf, colnames(finaldf)[i])\n    }\n    #fit arima\n    tsdf<-ts(finaldf)\n    xreg<-tsdf[,2:(ncol(tsdf)-1)]\n    dvdata<-tsdf[,ncol(tsdf)]\n    fit <- auto.arima(dvdata, max.p=5, max.q=5,\n                      max.P=2, max.Q=2, max.order=5, max.d=1, max.D=2, \n                      start.p=0, start.q=0, start.P=0, start.Q=0, \n                      stationary=FALSE, seasonal=TRUE,\n                      ic=c(\"aicc\", \"aic\", \"bic\"), stepwise=TRUE, trace=FALSE,\n                      approximation=(length(lh)>100 | frequency(lh)>12),\n                      test=c(\"kpss\",\"adf\",\"pp\"), seasonal.test=c(\"ocsb\",\"ch\"),\n                      allowdrift=TRUE, allowmean=TRUE, lambda=NULL, parallel=FALSE, num.cores=2,xreg=xreg)\n    saveRDS(fit, paste0(str_replace(input$depvar,\"/\",\".\"),\"_fit.rds\"))\n    output$plotsummary <- renderPrint({summary(fit)})\n    plotdata<-as.data.frame(cbind(fit$x,fitted(fit)))\n    colnames(plotdata)<-c(input$depvar,paste0(\"Fitted_\",input$depvar))\n    plotdata$Date<-as.character(finaldf$DATE)\n    plotdata<-reshape2::melt(plotdata, id.vars = \"Date\")\n    h1<-hPlot(x = \"Date\", y = \"value\", group = \"variable\", data = plotdata)\n    h1$xAxis(type = 'datetime', labels = list(format = '{value:%Y-%m-%d}'),title = list(text = 'Time'))\n    h1$yAxis(title = list(text = paste0('Value')))\n    h1$title(text=paste0(\"Fit plot for \", input$depvar))\n    return(h1)\n  })\n  output$chart4 <- renderChart2({\n    #get iv\n    serieslist<-unlist(strsplit(input$foreseriessim,\",\"))\n    signarr=unlist(strsplit(input$signfore,\",\"))\n    \n    # Create chart\n    for (i in 1:length(serieslist))\n    {\n      sign=signarr[i]\n      if (sign==\"+\"){\n        if (input$foreoutlook==\"Very Positive\")\n        {\n          prc=0.99\n        }else if (input$foreoutlook==\"Positive\"){\n          prc=0.75\n        }else if (input$foreoutlook==\"Neutral\"){\n          prc=0.5\n        }else if (input$foreoutlook==\"Negative\"){\n          prc=0.25\n        }else if (input$foreoutlook==\"Very Negative\"){\n          prc=0.01\n        }\n      }else{\n        if (sign==\"-\"){\n          if (input$foreoutlook==\"Very Positive\")\n          {\n            prc=0.01\n          }else if (input$foreoutlook==\"Positive\"){\n            prc=0.25\n          }else if (input$foreoutlook==\"Neutral\"){\n            prc=0.5\n          }else if (input$foreoutlook==\"Negative\"){\n            prc=0.75\n          }else if (input$foreoutlook==\"Very Negative\"){\n            prc=0.99\n          }\n        }\n      }\n      data<-read.csv(paste0(str_replace(serieslist[i],\"/\",\".\"),\"_\",Sys.Date(),\"_\",input$forecount,\"_\",input$simcount,\".csv\"))\n      outlook<-colQuantiles(data.matrix(data),probs=seq(from=prc, to=prc, by=0))[2:ncol(data)]\n      if (i==1)\n      {\n        xreg<-outlook\n      }else{\n        xreg<-cbind(xreg,outlook)\n      }\n    }\n    xreg<-data.frame(xreg)\n    colnames(xreg)<-paste0(str_replace(serieslist,\"/\",\".\"),\" - VALUE\")\n    #find Annualisation COnst\n    if (input$frequencyfore==\"daily\"){\n      ann=365\n    }else if (input$frequencyfore==\"weekly\"){\n      ann=52\n    }else if (input$frequencyfore==\"monthly\"){\n      ann=12\n    }else if (input$frequencyfore==\"quarterly\"){\n      ann=4\n    }else if (input$frequencyfore==\"annual\"){\n      ann=1\n    }else{\n      ann=4\n    }\n    #get core variables\n    n<-input$control\n    simdf<-read.csv('simdf.csv')\n    if (input$Fcore1==TRUE){\n      latest<-Quandl(input$Fcore1var,type='raw')\n      conxreg<-colnames(xreg)\n      simirf<-ann*100*(exp(simdf[simdf$varname=='Y',1:ncol(simdf)-1][n,]/100)-1)\n      xreg$Fore1<-t(1+simirf)*latest[1,2]\n      colnames(xreg)<-c(conxreg,paste0(str_replace(input$Fcore1var,\"/\",\".\"),\" - VALUE\"))\n    }\n    if (input$Fcore2==TRUE){\n      latest<-Quandl(input$Fcore2var,type='raw')\n      conxreg<-colnames(xreg)\n      simirf<-ann*100*(exp(simdf[simdf$varname=='C',1:ncol(simdf)-1][n,]/100)-1)\n      xreg$Fore2<-t(1+simirf)*latest[1,2]\n      colnames(xreg)<-c(conxreg,paste0(str_replace(input$Fcore2var,\"/\",\".\"),\" - VALUE\"))\n    }\n    if (input$Fcore3==TRUE){\n      latest<-Quandl(input$Fcore3var,type='raw')\n      conxreg<-colnames(xreg)\n      simirf<-ann*100*(exp(simdf[simdf$varname=='I',1:ncol(simdf)-1][n,]/100)-1)\n      xreg$Fore3<-t(1+simirf)*latest[1,2]\n      colnames(xreg)<-c(conxreg,paste0(str_replace(input$Fcore3var,\"/\",\".\"),\" - VALUE\"))\n    }\n    if (input$Fcore4==TRUE){\n      latest<-Quandl(input$Fcore4var,type='raw')\n      conxreg<-colnames(xreg)\n      xreg$Fore4<-t(1+simdf[simdf$varname=='L',1:ncol(simdf)-1][n,])*latest[1,2]\n      colnames(xreg)<-c(conxreg,paste0(str_replace(input$Fcore4var,\"/\",\".\"),\" - VALUE\"))\n    }\n    if (input$Fcore5==TRUE){\n      latest<-Quandl(input$Fcore5var,type='raw')\n      conxreg<-colnames(xreg)\n      simirf<-ann*100*(exp(simdf[simdf$varname=='pi',1:ncol(simdf)-1][n,]/100)-1)\n      xreg$Fore5<-t(1+simirf)*latest[1,2]\n      colnames(xreg)<-c(conxreg,paste0(str_replace(input$Fcore5var,\"/\",\".\"),\" - VALUE\"))\n    }\n    if (input$Fcore6==TRUE){\n      latest<-Quandl(input$Fcore6var,type='raw')\n      conxreg<-colnames(xreg)\n      xreg$Fore6<-t(1+simdf[simdf$varname=='R',1:ncol(simdf)-1][n,])*latest[1,2]\n      colnames(xreg)<-c(conxreg,paste0(str_replace(input$Fcore6var,\"/\",\".\"),\" - VALUE\"))\n    }\n    fit<-readRDS(paste0(str_replace(input$depvar,\"/\",\".\"),\"_fit.rds\"), refhook = NULL)\n    fcast <- forecast(fit, h=input$forecount, xreg=data.frame(xreg))\n    plotdata<-as.data.frame(cbind(fcast$mean,fcast$upper,fcast$lower))\n    plotdata$Period<-seq(1, as.numeric(input$forecount),1)\n    plotdata<-reshape2::melt(plotdata, id.vars = \"Period\")\n    h1<-hPlot(x = \"Period\", y = \"value\", group = \"variable\", data = plotdata)\n    h1$xAxis(title = list(text = 'Time'))\n    h1$yAxis(title = list(text = paste0('Value')))\n    h1$title(text=paste0(\"Forecast plot for \", input$depvar))\n    return(h1)\n  })\n  output$downloadmanual <- downloadHandler(\n    filename = function() { paste0(\"Stress Testing Manual.pdf\") },\n    content = function(file) {\n      file.copy('Stress Testing Manual.pdf', file)\n    }\n  )\n  observeEvent(input$do, {\n    do.call(file.remove,list(grep(\"*.csv\",list.files(getwd()))))\n    do.call(file.remove,list(grep(\"*.rds\",list.files(getwd()))))\n    session$sendCustomMessage(type = 'testmessage',\n                              message = 'Files Removed')\n  })\n  sw_gecon <- reactive({\n    # set our starting values for various parameters\n    isolate({\n      initv <- list(z = 1, z_f = 1, Q = 1, Q_f = 1, pi = 1, pi_obj = 1,\n                    epsilon_b = 1, epsilon_L = 1, epsilon_I = 1, epsilon_a = 1, epsilon_G = 1,\n                    r_k = 0.01, r_k_f = 0.01)\n      tmp <- initval_var(sw_gecon_orig, init_var = initv)\n      initf <- list(\n        beta = input$beta,            # Discount factor\n        tau = input$tau,            # Capital depreciation rate\n        varphi = input$varphi,         # Parameter of investment adjustment cost function\n        psi = input$psi,            # Capacity utilisation cost parameter\n        sigma_c = input$sigma_c,        # Coefficient of relative risk aversion\n        h = input$h,              # Habit formation intensity\n        sigma_l = 1 / input$sigma_l_inv,         # Reciprocal of labour elasticity w.r.t. wage\n        omega = input$omega,               # Labour disutility parameter,\n        alpha = input$alpha,\n        gamma_w = input$gamma_w,\n        lambda_w = input$lambda_w,\n        xi_w = input$xi_w,\n        gamma_p = input$gamma_p,\n        xi_p = input$xi_p,\n        r_pi = input$r_pi\n      )\n      tmp <- set_free_par(tmp, initf)\n      # find the steady state for that set of starting values\n      tmp <- steady_state(tmp)\n      \n      # solve the model in linearised form for 1st order perturbations/randomness\n      tmp <- solve_pert(tmp, loglin = TRUE)\n    })\n    input$goButton\n    return(tmp)\n    \n  })\n  sw_gecon_shocked <- reactive({\n    # set covariance matrix of the parameters to be used in shock simulation\n    a <- c(eta_b = input$eta_b ^ 2, eta_L = input$eta_L ^ 2, eta_I = input$eta_I ^ 2, \n           eta_a = input$eta_a ^ 2,\n           eta_w = input$eta_w ^ 2, eta_p = input$eta_p ^ 2,\n           eta_G = input$eta_G ^ 2, eta_R = input$eta_R ^ 2, eta_pi = input$eta_pi ^ 2)\n    tmp  <- set_shock_cov_mat(sw_gecon(), shock_matrix = diag(a), shock_order = names(a))\n    \n    # compute the moments with that covariance matrix\n    tmp <- compute_moments(tmp,sim=TRUE, nrun=1000)\n    return(tmp)\n  })\n  sw_gecon_irf <- reactive({\n    shock_row <- which(shocks$longer_name == input$shock_var)\n    compute_irf(sw_gecon_shocked(), var_list = c('C', 'Y', 'pi', 'I', 'L','R'), chol = T,\n                shock_list = list(shocks[shock_row, \"param\"]), path_length = as.numeric(input$forecount))\n  })\n  output$chart5 <- renderChart2({\n    sw_gecon_irf<-sw_gecon_irf()\n    irf<-as.data.frame(sw_gecon_irf@sim)\n    irf<-as.data.frame(t(irf))\n    colnames(irf)<-sw_gecon_irf@var_list\n    irf$period=seq(1,as.numeric(input$forecount),1)\n    plotdata<-reshape2::melt(irf, id.vars = \"period\")\n    h1<-hPlot(x = \"period\", y = \"value\", group = \"variable\", data = plotdata)\n    h1$xAxis(title = list(text = 'Time'))\n    h1$yAxis(title = list(text = paste0('Value')))\n    h1$title(text=paste0(\"IRF Plot for \", input$shock_var))\n    return(h1)\n  })\n  sw_sim <- eventReactive(input$Simulate, {\n    varlist<-NULL\n    if (input$core1==TRUE){\n      varlist<-c(varlist,'Y')\n    }\n    if (input$core2==TRUE){\n      varlist<-c(varlist,'C')\n    }\n    if (input$core3==TRUE){\n      varlist<-c(varlist,'I')\n    }\n    if (input$core4==TRUE){\n      varlist<-c(varlist,'L')\n    }\n    if (input$core5==TRUE){\n      varlist<-c(varlist,'pi')\n    }\n    if (input$core6==TRUE){\n      varlist<-c(varlist,'R')\n    }\n    simdf<-NULL\n    withProgress(message = 'Running Simulation', value = 0,{\n        for (i in 1:as.numeric(input$simcount))\n        {\n          shock_row <- which(shocks$longer_name == input$shock_var)\n          randpath<-random_path(sw_gecon_shocked(), var_list = varlist,shock_list = list(shocks[shock_row, \"param\"]), path_length = as.numeric(input$forecount)) \n          currsim<-as.data.frame(get_simulation_results(randpath))\n          currsim$varname<-rownames(currsim)\n          rownames(currsim)<-NULL\n          simdf<-rbind(simdf,currsim)\n          # Increment the progress bar, and update the detail text.\n          incProgress(1/as.numeric(input$simcount), detail = paste(\"completed part\", i))\n        }\n    })\n    write.csv(simdf,\"simdf.csv\",row.names = FALSE)\n    return('Simulation complete')\n  })\n  output$nText <- renderText({\n    sw_sim()\n  })\n  output$IVTABLE<-DT::renderDataTable({\n    #get iv\n    serieslist<-unlist(strsplit(input$foreseriessim,\",\"))\n    if (input$Fcore1==TRUE){\n      serieslist<-c(serieslist,'FRED/GDP')\n    }\n    if (input$Fcore2==TRUE){\n      serieslist<-c(serieslist,'FRED/PCECC96')\n    }\n    if (input$Fcore3==TRUE){\n      serieslist<-c(serieslist,'FRED/RINV')\n    }\n    if (input$Fcore4==TRUE){\n      serieslist<-c(serieslist,'FRED/LNU01000000')\n    }\n    if (input$Fcore5==TRUE){\n      serieslist<-c(serieslist,'RATEINF/INFLATION_USA')\n    }\n    if (input$Fcore6==TRUE){\n      serieslist<-c(serieslist,'PERTH/FEDF_M')\n    }\n    # Create chart\n    if (length(serieslist)==1)\n    {\n      #get data\n      eval(parse(text=paste0(\"data<-Quandl(code='\",serieslist,\"',type='raw',\",ifelse(input$transformfore==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transformfore,\"',\")),ifelse(input$frequencyfore==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequencyfore,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n    }else{\n      for (count in 1:length(serieslist)){\n        if (count==1){\n          str<-paste0(\"'\",serieslist[count],\"',\")\n        }else if (count<length(serieslist)){\n          str<-paste0(str,\"'\",serieslist[count],\"',\")\n        }else{\n          str<-paste0(str,\"'\",serieslist[count],\"'\")\n        }\n      }\n      str<-paste0(\"c(\",str,\")\")\n      #get data\n      eval(parse(text=paste0(\"data<-Quandl(code=\",str,\",type='raw',\",ifelse(input$transformfore==\"NULL\",\"transform=NULL,\",paste0(\"transform='\",input$transformfore,\"',\")),ifelse(input$frequencyfore==\"NULL\",\"collapse=NULL,\",paste0(\"collapse='\",input$frequencyfore,\"',\")),\"order='asc',meta=TRUE,force_irregular = TRUE)\")))\n    }\n    return(data)\n  })\n  output$pdfviewer <- renderText({\n    return(paste('<iframe style=\"height:600px; width:100%\" src=\"', input$pdfurl, '\"></iframe>', sep = \"\"))\n  })\n\n})\n\n",
    "created" : 1463030140014.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "936431048",
    "id" : "637B7D25",
    "lastKnownWriteTime" : 1463030133,
    "path" : "~/R/server.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}